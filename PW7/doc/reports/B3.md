## 活跃变量分析

#### B3-1
活跃变量分析总体采用课程 PPT 09-optimize 中的活跃变量分析算法，即根据定值-引用的结果计算活跃变量数据流的 IN 和 OUT。由于 Phi 指令中不同的选择会从不同的块引入数据，从而导致 OUT 的计算不再是简单的将后继的 IN 取并集，所以下面先暂时不考虑 Phi 指令。IN 和 OUT 的计算方式如下：

$$
IN[B] = use_B \cup (OUT[B] - def_B)\\
OUT[B] = \bigcup_{S \in succ_B} IN[S]
$$

根据上面的式子，每一轮迭代中，我们可以先根据上一次 IN 的结果计算 OUT，然后再计算 use 和 def，最后再据此计算 IN。下面为计算每一个值的过程：

* 对 OUT 的计算，直接根据定义，对于当前块的每个后继块（使用 `bb->get_succ_basic_blocks()` 获取当前块的所有后继块），将这个后继块的 IN 插入到当前块的 OUT。
* 对 def 和 use 的计算，需要枚举当前块当中每一条指令（暂时不考虑 Phi），并且对于这条指令中的每一个使用的局部变量 operand，如果它不在 def 中，那么就代表它使用的是前面的块计算的结果，所以需要加入 use。最后，对于当前指令写入的变量，如果这个变量不在 use 中，则说明这个变量是在这个块里新定义的，需要加入 def。
* 对 IN 的计算，由于式子比较复杂，所以按照优先级，先计算括号内的部分 $OUT[B] - def_B$，再与 $use_B$ 求并。具体实现上，就是将 IN 先初始化为 OUT，然后对于所有 $def_B$ 中的元素，将这个元素从 IN 集合中删除，最后将所有 $use_B$ 中的元素插入进 IN 中。
* 最后还需要进行一个对 IN 和 OUT 是否有变动的判断，以决定是否要结束迭代。在迭代开始之前，我们本来就需要清空 IN 和 OUT 的内容，所以可以定义两个集合：`prev_in` 和 `prev_out`，然后使用 `prev_in.swap(in)` 与 `prev_out.swap(out)` 将原先的 IN 和 OUT 存储下来，并将 IN 和 OUT 清空（因为新定义的集合初始就是空的，所以交换后空的集合就变成了现在的 IN 和 OUT）。同时，由于无法直接对两个集合判等（直接写 `in != prev_in` 会报错，因为 `WeakPtrSet` 中存储的 `WeakPtr` 无法实现判等操作），但是由于每一轮迭代之后 IN 和 OUT 的内容都只会新增不会减少（不会出现前一轮迭代后在 IN 和 OUT 中但是后一轮迭代后就不在的情况），所以可以直接比较两个集合的大小是否相等（即使用 `in.size() != prev_in.size()`）。

下面需要考虑 Phi 指令的情况。一个 Phi 指令的格式如下：
```
<result> = phi <type> [ <val0>, <label0> ], [ <val1>, <label1> ], ...
```

相当于，偶数位置（下标从 0 开始）的 operand 为引入的值，奇数位置的 operand 为跳转过来的模块。因此，在处理跳转前模块的 OUT 时，就需要根据跳转后模块的 Phi 指令中与跳转前模块相关的那一部分，将对应的引入值加入 OUT 中。最后，由于前面计算 use、def 和 IN 的过程中没有处理 Phi 指令，根据 use 的定义，Phi 指令中涉及到的这些值也应该在 use 中，因此也应当在 IN 中，所以在迭代结束后还得将 Phi 中所有的值都加入 IN 中。

因此，还要实现一个处理 Phi 指令的函数 `process_phi`，其包含三个参数，`values` 为需要将 Phi 中涉及到的值插入到的集合，`dst` 为跳转后的模块，`src` 为跳转前的模块，也可以为空，此时不针对特定的跳转前模块进行处理。函数内，对于 `dst` 模块中的每个指令，如果这个指令是 Phi 指令，则扫描这条 Phi 指令中每一组 operand，若 `src` 不为空，则只在找到跳转过来的模块为 `src` 的地方时将对应的值插入到集合，否则将所有涉及到的值都插入到集合。

因此，在程序中需要做以下改动：

* 在计算 OUT 的部分，每次将一个后继块 `succ` 的 IN 加入到当前块 `bb` 的 OUT 之后，需要执行一次 `process_phi(out, succ, bb)`；
* 在计算 def 和 use 的部分，对于指令是 Phi 的情况，需要在开头加一行，根据定义将指令得到的值加入 def，然后 continue。
* 在迭代结束之后，需要对每一个块 `bb` 执行一次 `process_phi(bb->get_live_in(), bb, nullptr)`。

进行完这些操作之后，即可实现整个活跃变量分析的优化。
